
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>java基础之：JDBC - AIX Zing</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="&lt;br/&gt;光荣在于平淡&lt;br/&gt;艰巨在于漫长&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;无论我多早迎接这清晨&lt;br/&gt;在路上&lt;br/&gt;都会有人在&lt;br/&gt;我以为别人还在梦乡&lt;br/&gt;但无论什么时候&lt;br/&gt;这个世界都比我快一步,JDBC是Java连接数据库的标准，为了兼容大部分数据库，Java提出了JDBC标准，通过这个标准，让各个数据库提供实现支持，这样实现一处编码，处处运行的Java特性。
习惯了ORM框架，却忘记了原,"> 
    <meta name="author" content="zing"> 
    <link rel="alternative" href="atom.xml" title="AIX Zing" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    <link rel="stylesheet" href="/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">AIX Zing</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xzing.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">java基础之：JDBC</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">java基础之：JDBC</h1>
        <div class="stuff">
            <span>三月 09, 2017</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/JDBC/">JDBC</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Java/">Java</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/数据库/">数据库</a></li></ul>


        </div>
        <div class="content markdown">
            <p>JDBC是Java连接数据库的标准，为了兼容大部分数据库，Java提出了JDBC标准，通过这个标准，让各个数据库提供实现支持，这样实现一处编码，处处运行的Java特性。</p>
<p>习惯了ORM框架，却忘记了原本的JDBC，所以我觉得有必要复习来夯实一下基础。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-719a927e4839a667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<h2 id="0x00-JDBC-历史"><a href="#0x00-JDBC-历史" class="headerlink" title="0x00 JDBC 历史"></a>0x00 JDBC 历史</h2><p>JDBC是Sun公司为了能够让SQL访问统一的一套纯JAVA API设计的一套接口，这种接口是遵循了微软的ODBC API模式。其驱动实现是各家数据库供应商编写的，通过JDBC API可以通过驱动实现数据库通信。</p>
<h2 id="0x01-链接数据库回顾"><a href="#0x01-链接数据库回顾" class="headerlink" title="0x01 链接数据库回顾"></a>0x01 链接数据库回顾</h2><p>基本Web常用的数据库都是有供Java链接的驱动，</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-d0884440199c9cc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三层结构"></p>
<p>那么如何使用JDBC？<br>写个Demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zing on 2017/3/7.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">testJDBC</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IOException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">//JDBC使用类似URL的数据源描述</span></span><br><span class="line">        String url = <span class="string">"jdbc:mysql://localhost:3306/demo"</span>;<span class="comment">//忽略</span></span><br><span class="line">        <span class="comment">//但是我们一般不会直接这样写死。而是使用配置来描述数据源，用户名，密码</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        FileInputStream propertiesFile = <span class="keyword">new</span> FileInputStream(<span class="string">"JDBC.properties"</span>);</span><br><span class="line">        props.load(propertiesFile);</span><br><span class="line">        propertiesFile.close();</span><br><span class="line"></span><br><span class="line">        String DriverStr = props.getProperty(<span class="string">"jdbc.Driver"</span>);</span><br><span class="line">        String urlStr = props.getProperty(<span class="string">"jdbc.url"</span>);</span><br><span class="line">        String userName = props.getProperty(<span class="string">"jdbc.name"</span>);</span><br><span class="line">        String passcode = props.getProperty(<span class="string">"jdbc.passworld"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开数据库链接</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(urlStr,userName,passcode);</span><br><span class="line">        <span class="comment">//执行SQL</span></span><br><span class="line">        Statement sta = connection.createStatement();</span><br><span class="line">        <span class="comment">//executeUpdate可以返回数据库更新的行数</span></span><br><span class="line">        <span class="keyword">int</span> efactRow = sta.executeUpdate(<span class="string">"UPDATE USER SET Permition = 'admin' WHERE username = 'Zing'"</span>);</span><br><span class="line">        <span class="comment">//executeQuery可以返回一个查询的结果集，这个集合的迭代器略有不同Iterator,没有hasNext方法，初始是，指针在数据前，必须调用next方法才能读取第一行数据</span></span><br><span class="line">        ResultSet resultSet = sta.executeQuery(<span class="string">"SELECT * FROM USER ;"</span>);</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="comment">//当前行获取第一栏的值，具体类型需要看数据库实现</span></span><br><span class="line">            resultSet.getString(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭语句</span></span><br><span class="line">        sta.close();</span><br><span class="line">        <span class="comment">//关闭结果集</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        <span class="comment">//关闭数据库连接</span></span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        一般情况下，关闭的操作会放在catch语句的finally块中，catch处理数据库异常，finally来关闭连接</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面写的是大杂烩，一般会将获取连接抽取成一个方法，异常也会捕获，并在try/catch/finally中的finally块中，关闭数据库连接。</p>
<p>API用法可以看看<code>java.sql.Connection</code>，<code>java.sql.Statement</code>，<code>java.sql.ResultSet</code>，这样，基本的操作就可以了然了。</p>
<blockquote>
<p><em><code>boolean execute(String sql) throws SQLException;</code>这个方法可以执行任何SQL，返回执行是否成功</em>。慎用。</p>
</blockquote>
<h2 id="0x02-预编译SQL"><a href="#0x02-预编译SQL" class="headerlink" title="0x02 预编译SQL"></a>0x02 预编译SQL</h2><p>PrepareStatement，一个可以让数据库预编译SQL的API。<br>并不是所有的SQL都是写死的，例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> UserAccount <span class="keyword">Where</span> <span class="keyword">Name</span> =</span><br></pre></td></tr></table></figure></p>
<p>根据名称来查找用户，这里的名字自然是用户自己定义的，如果用Statement，则应该这么写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUserByName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  Statement  sta = connection.createStatement();</span><br><span class="line">  String findByName = <span class="string">"SELECT * FROM USER WHERE Name=' "</span>+name+<span class="string">" ';"</span>;</span><br><span class="line">  ResultSet resultSet = sta.executeQuery(findByName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将name交给普通用户来输入，则没什么问题，但是 如果交给黑客，name他会输入 <code>小明&#39; OR &#39;1&#39; = &#39;1</code>,这样语句拼接后就会变成<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> <span class="keyword">Name</span>=<span class="string">' 小明'</span> <span class="keyword">OR</span> <span class="string">'1'</span> = <span class="string">'1'</span>;</span><br></pre></td></tr></table></figure></p>
<p>这一句就会把数据库所有的用户全部查出来了，很严重的注入漏洞，基本就会被脱库了。</p>
<p>所以Java JDBC定义的预编译SQL的API。<br>上例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testJDBC</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Statement sta = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preSta = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = getConnection();</span><br><span class="line">            <span class="comment">//执行SQL</span></span><br><span class="line">            </span><br><span class="line">            String findByName = <span class="string">"SELECT * FROM USER WHERE Name=?;"</span>;</span><br><span class="line">            preSta = connection.prepareStatement(findByName);</span><br><span class="line">            preSta.setString(<span class="number">1</span>,<span class="string">"Zing"</span>);</span><br><span class="line">            resultSet = preSta.executeQuery();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                一般情况下，关闭的操作会放在catch语句的finally块中，catch处理数据库异常，finally来关闭连接</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//关闭语句</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                preSta.close();</span><br><span class="line">                <span class="comment">//关闭结果集</span></span><br><span class="line">                resultSet.close();</span><br><span class="line">                <span class="comment">//关闭数据库连接</span></span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IOException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">//JDBC使用类似URL的数据源描述</span></span><br><span class="line">        <span class="comment">//但是我们一般不会直接这样写死。而是使用配置来描述数据源，用户名，密码</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        FileInputStream propertiesFile = <span class="keyword">new</span> FileInputStream(<span class="string">"JDBC.properties"</span>);</span><br><span class="line">        props.load(propertiesFile);</span><br><span class="line">        propertiesFile.close();</span><br><span class="line"></span><br><span class="line">        String DriverStr = props.getProperty(<span class="string">"jdbc.Driver"</span>);</span><br><span class="line">        String urlStr = props.getProperty(<span class="string">"jdbc.url"</span>);</span><br><span class="line">        String userName = props.getProperty(<span class="string">"jdbc.name"</span>);</span><br><span class="line">        String passcode = props.getProperty(<span class="string">"jdbc.passworld"</span>);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(urlStr, userName, passcode);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 顺便重构了之前的代码。<br>我们用 <code>?</code>占位，留下可变参数的位置，后来再用<code>setString(int parameterIndex, String x)</code>这个方法将数据填充进SQL，这样，如果参数含有SQL关键字时，就不能通过编译，查不到结果。可以避免SQL注入。</p>
<p>preSta.setString(1,”Zing”);表示，在第一个<code>?</code>处设置参数为<code>Zing</code><br>当然参数是数字，日期时，可以使用，<br><code>void setDouble(int parameterIndex, double x) throws SQLException</code><br><code>setDate(int parameterIndex, java.sql.Date x)
            throws SQLException;</code></p>
<p>等方法，根据不同类型设置参数。</p>
<h2 id="0x03-数据库类型与转义"><a href="#0x03-数据库类型与转义" class="headerlink" title="0x03 数据库类型与转义"></a>0x03 数据库类型与转义</h2><p>数据库类型和Java类型是有一点不一样的，但是JDBC定义了其中的大部分类型，这里不一一列举</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-1b51a004c32f21c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MySQL部分类型对照表，有兴趣可以查一查"></p>
<p>JDBC中的转义是为了让Java访问数据库时，得到普遍的支持。一般用于下列特性</p>
<ul>
<li>时间日期的字面常亮</li>
<li>标量函数调用</li>
<li>存储过程调用</li>
<li>外连接查询</li>
<li>LIKE子句中转义字符</li>
</ul>
<p>数据库的日期转换成Java的日期，是通过ISO8601标准衡定并相互转换的</p>
<blockquote>
<p>d表示DATE、t表示TIME、ts表示TIMESTANP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;d &apos;2017-01-22&apos;&#125;</span><br><span class="line">&#123;t &apos;19:30:29&apos;&#125;</span><br><span class="line">&#123;ts &apos;2017-01-22 19:30:29.989&apos;&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>标量函数是获取一个数值的函数，一般调用时嵌入标准函数名和参数，这个很少见到有人使用的，就不举例了。</p>
<p>存储过程，是数据库自建的存储方式，不同的数据库存储过程基本不一样，要调用存储过程，需要用call来进行转义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;call PROC01(?,?)&#125;</span><br><span class="line">&#123;call PROC02&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你不明白什么存储过程，可以看看数据库相关的资料。</p>
<p>外连接，就是Outter Join，借用核心卷II中的例子<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &#123;oj Books <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Publishers <span class="keyword">ON</span> Books.Publish_ID = Publishers.Publish_ID &#125;</span><br></pre></td></tr></table></figure></p>
<p>这条语句表示查询找不到出版商的书，相反如果是<code>RIGHT OUTER JOIN</code>则会查询出没有出版书的出版商，如果需要查到全部，则用<code>FULL OUTER JOIN</code><br>。这里用转义是因为有些数据库实现不太统一。</p>
<p>Like子句转义，是因为下划线和百分号在Like条件里是特殊的含义，需要用转义来表示<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">User</span> <span class="keyword">WHERE</span> <span class="keyword">Name</span> <span class="keyword">LIKE</span> %!_%ming &#123;escape <span class="string">'!'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>{escape ‘!’}表示将！定义为转义符号，!_表示字面量下划线</p>
<h2 id="0x04-事务"><a href="#0x04-事务" class="headerlink" title="0x04 事务"></a>0x04 事务</h2><p>为了保证数据和业务逻辑的完整性，我们可以将一系列的SQL语句构建成一个事物，当所有语句都顺利执行的时候，事务可以被提交。但是如果中途被阻碍，则数据会被回滚，将数据恢复成执行前的样子。</p>
<p>首先需要关闭数据库自动提交<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.setAutoCommit(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>然后根据实际业务执行多条UPDATE INSERT DELETE语句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">statement.executeUpdate(<span class="string">"SQL1"</span>);</span><br><span class="line">statement.executeUpdate(<span class="string">"SQL2"</span>);</span><br><span class="line">statement.executeUpdate(<span class="string">"SQL3"</span>);</span><br></pre></td></tr></table></figure></p>
<p>当所有语句顺利执行后，调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.commit();</span><br></pre></td></tr></table></figure></p>
<p>如果遇到异常或错误，则可以调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.rollback();</span><br></pre></td></tr></table></figure></p>
<p>其中JDBC支持事务保存点和批量更新<br>保存点：将事务的某一阶段设置为保存点后，可以控制回滚时，恢复到这个保存点的数据。从而更加精确的控制回滚操作<br>批量更新就是将大量数据一次性存入，或修改大量数据时使用的。两个🌰：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">statement.executeUpdate(<span class="string">"SQL1"</span>);</span><br><span class="line">Savepoint step1 = connection.setSavepoint();</span><br><span class="line">statement.executeUpdate(<span class="string">"SQL2"</span>);</span><br><span class="line"><span class="keyword">if</span>(something==<span class="keyword">false</span>)&#123;</span><br><span class="line">  connection.rollback(step1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String updateSQL = <span class="string">"……"</span>;</span><br><span class="line">statement.addBatch(updateSQL);</span><br><span class="line"><span class="keyword">while</span>(needUpdate)&#123;</span><br><span class="line">  command = <span class="string">"……"</span>+<span class="string">"updateSQL2"</span></span><br><span class="line">  statement.addBatch(updateSQL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量执行</span></span><br><span class="line"><span class="keyword">int</span> effectRows = statement.executeBatch();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><em>批量执行中一定不能有查询语句，否则会抛出异常。</em></strong></p>
</blockquote>
<h2 id="0x05-文件查询和存入数据库"><a href="#0x05-文件查询和存入数据库" class="headerlink" title="0x05 文件查询和存入数据库"></a>0x05 文件查询和存入数据库</h2><p>不建议这么搞，数据库存入太多大文件会导致数据库庞大，备份和恢复的成本将增加。<br>在数据库中，二进制大对象称为Blob，字符型大对象为Clob<br>这里演示一下查询和存储<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取</span></span><br><span class="line"> PreparedStatement preparedStatement01 = connection.prepareStatement(<span class="string">"SELECT picture FROM PictureTab WHERE picName=?;"</span>);</span><br><span class="line"> preparedStatement01.setString(<span class="number">1</span>,<span class="string">"superman"</span>);</span><br><span class="line"> ResultSet rs = preparedStatement01.executeQuery();</span><br><span class="line"> <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">     Blob picBlob = rs.getBlob(<span class="number">1</span>);</span><br><span class="line">     Image pic = ImageIO.read(picBlob.getBinaryStream());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//存储</span></span><br><span class="line"> Blob pictureBlob = connection.createBlob();</span><br><span class="line"> <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line"> OutputStream outStram = pictureBlob.setBinaryStream(offset);</span><br><span class="line"> ImageIO.write(pictureBlob,<span class="string">"PNG"</span>,outStram);</span><br><span class="line"> PreparedStatement preparedStatement02 = connection.prepareStatement(<span class="string">"INSERT INTO PictureTab VALUE (?,?);"</span>);</span><br><span class="line"> preparedStatement02.setString(<span class="number">1</span>, <span class="string">"SuperMan"</span>);</span><br><span class="line"> preparedStatement02.setBlob(<span class="number">2</span>,pictureBlob);</span><br><span class="line"> preparedStatement02.executeUpdate();</span><br></pre></td></tr></table></figure></p>
<h2 id="0x06-其他一些概念"><a href="#0x06-其他一些概念" class="headerlink" title="0x06 其他一些概念"></a>0x06 其他一些概念</h2><ul>
<li>元数据：数据库的结构和表信息等描述数据库结构和组成部分的数据</li>
<li>多结果集：一次查询，使用多个Select SQL语句是，会得到一个多结果集</li>
<li>可滚动结果集：可以向前，向后查询的结果集，之前的只能用Next向后查询，使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stat = Connection.createStatement(ResultSet.TYPE_SCROLL_INSENSTIVE , ResultSet.CONCUR_READ_ONLY )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在获取结果集的时候，会变成一个可滚动集。</p>
<ul>
<li>获取数据库生成键值<code>statemwnt.getGeneratedKeys();</code></li>
<li>行集 RowSet接口继承了ResultSet，但不需要长时间占用数据库链接。</li>
</ul>
<hr>
<p>love&amp;peace<br>若有错误请不吝指出，谢谢。<br>我的博客：<a href="https://micorochio.github.io/" target="_blank" rel="noopener">https://micorochio.github.io/</a><br>转载请注明出处:<a href="https://micorochio.github.io/2017/03/10/basic-of-java-JDBC/。" target="_blank" rel="noopener">https://micorochio.github.io/2017/03/10/basic-of-java-JDBC/。</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
