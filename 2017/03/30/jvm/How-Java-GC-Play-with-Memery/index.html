
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Java的GC如何玩弄对象 - AIX Zing</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="&lt;br/&gt;光荣在于平淡&lt;br/&gt;艰巨在于漫长&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;无论我多早迎接这清晨&lt;br/&gt;在路上&lt;br/&gt;都会有人在&lt;br/&gt;我以为别人还在梦乡&lt;br/&gt;但无论什么时候&lt;br/&gt;这个世界都比我快一步,Java的GC是什么，应该做Java的人都知道。但是其实GC的历史要比Java早，Java出现之前，人们就开始研究：

哪些内存需要回收
哪些内存什么时候回收
怎样回收

然后就有了GC，而Java,"> 
    <meta name="author" content="zing"> 
    <link rel="alternative" href="atom.xml" title="AIX Zing" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.ico"> 
    
    <link rel="stylesheet" href="/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">AIX Zing</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xzing.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Java的GC如何玩弄对象</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">Java的GC如何玩弄对象</h1>
        <div class="stuff">
            <span>三月 30, 2017</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/FS计划/">FS计划</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/GC/">GC</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/JVM/">JVM</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Java/">Java</a></li></ul>


        </div>
        <div class="content markdown">
            <p>Java的GC是什么，应该做Java的人都知道。但是其实GC的历史要比Java早，Java出现之前，人们就开始研究：</p>
<ul>
<li>哪些内存需要回收</li>
<li>哪些内存什么时候回收</li>
<li>怎样回收</li>
</ul>
<p>然后就有了GC，而Java解决的这3件事情，就目前看来，效果还可以。解决了很多的内存问题。但是，GC并不能解决所有内存动态分配的问题，尤其是高并发的软件中，了解GC，方便解决内存溢出问题，更好的控制和调节程序的回收和分配内存。<br><a id="more"></a></p>
<h2 id="I-对象生死判定算法"><a href="#I-对象生死判定算法" class="headerlink" title="I 对象生死判定算法"></a>I 对象生死判定算法</h2><p>感叹一下乔布斯当年看中的两项技术Internet 和OOP Language，现在都如日中天，不愧是乔帮主。</p>
<p>Java是OOP的经典语言之一，OOP语言号称万物皆对象，对象用不到了，那就应该离开内存了，这就是对象的死亡。是不是死掉的呢</p>
<p>死掉的对象，自然需要GC来处理，但是GC怎么知道对象已经死掉了呢？</p>
<h3 id="1x01-引用计数算法"><a href="#1x01-引用计数算法" class="headerlink" title="1x01  引用计数算法"></a>1x01  <strong>引用计数算法</strong></h3><p>就是给每个对象添加一个引用计数器，当对象被引用一次，计数器就+1；引用失效时，计数器就-1。当计数器为0，就说明对象死了。这个方法实现简单，效率也可观。但是，主流的JVM没用这个算法，因为这个算法很难解决循环引用的问题。</p>
<blockquote>
<p><strong>什么是循环引用？</strong><br>就是多个对象，互相引用对方作为属性，下面就是A依赖B，B依赖C，C依赖A的循环引用。<br><img src="http://upload-images.jianshu.io/upload_images/1112615-ac9f5b3e247bc4a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这就是，百度一下就知道了"></p>
</blockquote>
<p>当然，还有更细致的分法：</p>
<ul>
<li><em>强引用</em><br><code>String a = new String()</code>就是这样的，强引用存在，GC就不能回收对象</li>
<li><em>软引用</em><br>有用单非必须的对象，这些对象在内存快溢出就会被回收，回收内存依旧不够才会抛出异常</li>
<li><em>弱引用</em><br>比软引用还非必要，每次GC来的时候都会被回收</li>
<li><em>虚引用</em><br>最弱的引用，无法通过这个引用来获取对象，唯一的作用是在被回收事给系统一个通知</li>
</ul>
<h3 id="1x02-可达性算法"><a href="#1x02-可达性算法" class="headerlink" title="1x02 可达性算法"></a>1x02 <strong>可达性算法</strong></h3><p>这个比上面高大上一点，Java通过可达性分析来判定对象是否还被引用。什么的可达性分析呢：<br>Java会从一些叫做GCRoot的对象开始向下遍历，可以遍历到的对象，就是被引用的对象，不可以遍历到的对象就是不可达对象，就是死掉的对象了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-70117103618610c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="蓝色表示可达对象
灰色表示不可达对象"><br><em>蓝色表示可达对象灰色表示不可达对象</em></p>
<p>在图上可以看到，从GCRoot开始，蓝色部分的对象都可以被遍历到，儿灰色部分，即使 Object A 可以遍历到 Object B 和Object C，但是却没有了GCRoot 引用，所以就属于不可达的死亡对象了<br><br>（是不是找不到对象就可以死了<code>T^T</code>）。</p>
<p>GCRoot 包括：栈中引用对象，方法区静态引用对象，方法区常量引用对象，本地方法引用对象（Native层的）</p>
<h2 id="II-GC回收垃圾的算法"><a href="#II-GC回收垃圾的算法" class="headerlink" title="II GC回收垃圾的算法"></a>II GC回收垃圾的算法</h2><p>既然已经能判断了垃圾有哪些，接下来就简单讲讲对垃圾对象如何清理</p>
<h3 id="2x01-标记-清除算法"><a href="#2x01-标记-清除算法" class="headerlink" title="2x01  标记-清除算法"></a>2x01  标记-清除算法</h3><p>跟名字一样，先把死掉的对象标记出来，然后清除，大部分算法是基于这个思想，不足之处也很明显，1是效率问题，标记和清除的过程都慢，2是空间问题，清除之后会带啦大量的不连续碎片空间。小的碎片会放不下大对象，导致大对象创建时又会触发一次回收</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-f653d6c28c45b880.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收前"><br><em>回收前</em></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-206b89e6f5936577.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收后"><br><em>回收后</em></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-e89082cc4f16a68f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="2x02-复制算法"><a href="#2x02-复制算法" class="headerlink" title="2x02 复制算法"></a>2x02 复制算法</h3><p>为了解决效率问题，有了复制算法，这种算法将内存分成相同大小的两块</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-ffaf64836f7d71d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收前"><br><em>回收前</em></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-81fc977d72535b59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收后"><br><em>回收后</em></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-bbd542e94ead259d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其实并不是非要等比划分内存的，大部分对象死的很早Hotspot是划分了三块区域，一块大的两块小的，大的叫Eden，小的叫survivor，大小比例为8:1。清理时将Eden和survivor中存活的对象复制到另一块survivor内存上，然后，清理掉用过的两块内存，下次再用。当survivor不够大的时候，需要依靠新的分配担保去拓展空间。</p>
<h3 id="2x03-标记-整理算法"><a href="#2x03-标记-整理算法" class="headerlink" title="2x03 标记-整理算法"></a>2x03 标记-整理算法</h3><p>综合复制和标记算法，整理算法会把有用的存活对象向y，一端移动，这样避免了复制算法浪费那么多内存，也不会像普通标记回收算法一样导致内存碎片过于严重。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-141b22c5c8f8efce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收前"><br><em>回收前</em></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1112615-821ce46430e3de22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收后"><br><em>回收后</em></p>
<h3 id="2x04-分代收集算法"><a href="#2x04-分代收集算法" class="headerlink" title="2x04 分代收集算法"></a>2x04 分代收集算法</h3><p>将java堆内存分成老年代，新生代。根据经验，新生代死亡比较快，老年代比较持久。所以一般新生代区域使用复制方法，只需要复制几个就可以了，老年代比较持久，所以一般用标记清除，或标记整理来回收。</p>
<h2 id="III-小结"><a href="#III-小结" class="headerlink" title="III 小结"></a>III 小结</h2><p>GC是Java中最诱人的处理内存的方式，也是最令人难受的处理方式。想要深入java，GC是绕不过的必经之路。了解GC的运作方法，可以帮助程序员处理更深层次的Java问题，做出更深层次的系统优化。希望我的小总结能给你带来帮助</p>
<p><strong>转载请注明出处。</strong><a href="https://micorochio.github.io/2017/03/31/How-Java-GC-Play-with-Memery/" target="_blank" rel="noopener">https://micorochio.github.io/2017/03/31/How-Java-GC-Play-with-Memery/</a><br>ps我的博客：<a href="https://micorochio.github.io/" target="_blank" rel="noopener">https://micorochio.github.io/</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div>


    </div>
    
        <div class="side">
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-对象生死判定算法"><span class="toc-number">1.</span> <span class="toc-text">I 对象生死判定算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1x01-引用计数算法"><span class="toc-number">1.1.</span> <span class="toc-text">1x01  引用计数算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1x02-可达性算法"><span class="toc-number">1.2.</span> <span class="toc-text">1x02 可达性算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#II-GC回收垃圾的算法"><span class="toc-number">2.</span> <span class="toc-text">II GC回收垃圾的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2x01-标记-清除算法"><span class="toc-number">2.1.</span> <span class="toc-text">2x01  标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2x02-复制算法"><span class="toc-number">2.2.</span> <span class="toc-text">2x02 复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2x03-标记-整理算法"><span class="toc-number">2.3.</span> <span class="toc-text">2x03 标记-整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2x04-分代收集算法"><span class="toc-number">2.4.</span> <span class="toc-text">2x04 分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#III-小结"><span class="toc-number">3.</span> <span class="toc-text">III 小结</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
